---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit and run README.Rmd file to regenerate README.md -->

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.path = "man/figures/README-",
    out.width = "100%",
    fig.width = 8.5,
    fig.height = 3,
    dpi = 250,
    message = FALSE
)
```
# daRt

<!-- badges: start -->
<!-- badges: end -->
The daRt package provides a very quick and flexible way to import data that is produced by the Discrete Anisotropic Radiative Transfer (DART) model. The data in daRt are formatted in a way that facilitates rapid data analysis. 

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("willmorrison1/daRt")
```
Load the package
```{r load the package}
library(daRt)
```
## Overview
This section demonstrates the most basic use of daRt to load the "directions" data for the default "cesbio" simulation provided in this respository.
Determine the type of files you want to load
```{r}
sF <- simulationFilter(product = "directions")
```
Define a simulation directory
```{r}
simulationDir <- "man/data/cesbio"
```
Load data for the given simulation using the predetermined file types
```{r}
simData <- daRt::getData(x = simulationDir, sF = sF)
```
Use the data in the given "long" format
```{r}
head(simData@data, n = 3)
```
### SimulationFilter
The "SimulationFilter" object describes what data you want to extract from a DART output directory structure.
Show the current configuration of the SimulationFilter
```{r}
sF
```
List the 'setter' and 'accessor' methods available
```{r}
methods(class = "SimulationFilter")
```
Use these methods to edit the SimulationFilter object e.g. the "bands" or "iterations" that you want to load
```{r}
bands(sF) <- c("BAND0", "BAND1")
iters(sF) <- "ITER1"
```
###SimulationFiles
The "SimulationFiles" object contains all information on the files that will be loaded, based on the provided "SimulationFilter". It is used to explore the DART output directory structure. 
First define the simulation directory. For this example, 'simulationDir' is a relative directory (based on the github data provided) and consists of one simulation.
```{r}
#define the simulation directory
simulationDir <- "man/data/cesbio"
```
If you install the package using devtools::install_github then the "cesbio" simulation files will not be available automatically. To use these files, get them from github manually or use your own 'cesbio' simulation which is shipped with the DART model by default. 

The simulation directory should be the base directory of the simulation. E.g. within 'simulationDir' there should be the simulation 'input' and 'output' directories.
```{r}
list.files(simulationDir)
```
Now we have the simulation directory clarified, explore the files in the simulation that correspond to this filter
```{r}
simFiles <- daRt::getFiles(x = simulationDir, sF = sF)
```
Explore the output of this to check we happy to continue and load the data. daRt::getFiles is essentially a 'dry-run' of the data extraction
```{r}
files(simFiles)
```
###SimulationData
The "SimulationData" object contains all data for the given "SimulationFilter". Do the following to extract DART output data using the 'getData' method
```{r}
simData <- daRt::getData(x = simulationDir, sF = sF)
#also can do this using simFiles object
simData_fromFiles <- daRt::getData(x = simFiles)
identical(simData_fromFiles, simData)
```
###Simple plotting
By having data in a "long" format, it is easy to perform analysis on the data.
```{r plot data example}
#plot using ggplot2
library(ggplot2)
plotOut <- ggplot(simData@data) +
    geom_point(aes(x = zenith, y = value, colour = azimuth)) +
    facet_wrap(~ band) +
    theme(aspect.ratio = 1)
plot(plotOut)
```

##Further examples
This section provides further misc examples and guidance for reference.

###SimulationFilter editing
To look at images for Bands 0, 1 and 2; iterations 1 and 2, and images 5 and 7, create the relevant SimulationFilter then load the data 
```{r images example}
#create SimulationFilter
sF <- simulationFilter(product = "images", 
                       bands = c("BAND0", "BAND1", "BAND2"),
                       iters = c("ITER1", "ITER2"),
                       variables = "BRF",
                       imageNo = c(5, 7),
                       imageType = "ima")
#load data
simData <- daRt::getData(x = simulationDir, sF = sF)
#simple plot of data
ggplot(simData@data) + 
    geom_raster(aes(x = x, y = y, fill = value)) +
    facet_grid(band ~ imageNo + iter) +
    theme(aspect.ratio = 1)
```
Alter the SimulationFilter again to now look at radiative budget files
```{r RB3D example}
product(sF) <- "rb3D"
simData <- daRt::getData(x = simulationDir, sF = sF)
```

###Radiative budget
The 3D radiative budget data are stored with the X, Y and Z location of each cell, stored in 3 columns
```{r RB3D data example}
head(simData@data, n = 3)
```
Plot a horizontal slice of the radiative budget data
```{r}
ggplot(simData@data) + 
    geom_raster(aes(x = X, y = Y, fill = value)) +
    facet_grid(band + variablesRB3D~ Z) +
    theme(aspect.ratio = 1)
```
That's a lot of data! It is important to set the "SimulationFilter" to match what data you want so that this doesn't happen. Also, the process can use a lot of memory when many large files are loaded so try to only load in the files you need in the first place. Further guidance on meory management are given elsewhere.
The below example uses the simple "dplyr" approach to work with the data. Here we look at the lowest horizontal layer of each 3D radiative budget array (i.e. Z = 1) rather than all layers (above plot) and plot the smaller dataset.
```{r}
library(dplyr)
simData_filtered <- simData@data %>%
    dplyr::filter(Z == 1)
#plot again and tweak the plot
ggplot(simData_filtered) + 
    geom_raster(aes(x = X, y = Y, fill = value)) +
    facet_grid(band ~ variablesRB3D) +
    theme(aspect.ratio = 1) +
    theme_bw() +
    theme(panel.spacing = unit(0, "cm"), 
          strip.text = element_text(size = 6, 
                                    margin = margin(0.05, 0.05, 0.05, 0.05, unit = "cm"))) +
    scale_fill_distiller(palette = "Spectral")
```

###Memory management
'getData()' loads all data to memory which is problematic when loading many files. In this section, a relatively large dataset is loaded in two ways. Option one uses the default 'getData()' to load all data at once, whereas Option 2 offers a solution to process data with a much smaller memory footprint. 

####Option 1: Load data all at once
Load all radiative budget products at once into memory and take the mean of each horizontal layer. 
```{r}
sF <- simulationFilter(product = "rb3D", 
                       bands = c("BAND0", "BAND1", "BAND2"), 
                       iters = "ITER1", "ITER2", "ILLUDIFF", "ILLUDIR",
                       typeNums = "",
                       variables = "RADIATIVE_BUDGET")
simFiles <- daRt::getFiles(simulationDir, sF = sF)

```
There are three files each with 6 variables and each as a 3D array - i.e. quite a lot of data
```{r}
files(simFiles)
```
Load in the data all at once. It is relatively memory intensive
```{r}
simData <- daRt::getData(x = simFiles)

```
and gives a relatively large array of data
```{r}
head(simData@data, n = 3)
dim(simData@data)
```
Get the mean of non-zero values across each vertical layer of each variable, band, etc
```{r}
statVals <- simData@data %>%
    dplyr::group_by(X, Y, variablesRB3D, band, iter, typeNum, simName) %>%
    dplyr::summarise(meanVal = mean(value[value != 0], na.rm = TRUE))
```
Then plot these values
```{r, fig.height = 5}
ggplot(statVals) +
    geom_raster(aes(x = X, y = Y, fill = meanVal)) +
    facet_grid(iter + band ~ variablesRB3D) +
    theme(strip.text = element_text(size = 5, margin = margin(0.1, 0.1, 0.1, 0.1))) +
    theme(aspect.ratio = 1)
```

####Option 2: Load data in sections and process each section
Do the same analysis as when loading all data at once, but process each band separately to save on memory usage.
```{r}
sF <- simulationFilter(product = "rb3D", 
                       bands = c("BAND0", "BAND1", "BAND2"), 
                       iters = "ITER1", "ITER2", "ILLUDIFF", "ILLUDIR",
                       typeNums = "",
                       variables = "RADIATIVE_BUDGET")
allBands <- bands(simData)
allBands
simDataList <- vector(mode = "list", length = length(allBands))
for (i in 1:length(allBands)) {
    bands(sF) <- allBands[i]
    simDataPiece  <- daRt::getData(x = simulationDir, sF = sF)
    simDataList[[i]] <- simDataPiece@data %>%
        dplyr::group_by(X, Y, variablesRB3D, band, iter, typeNum, simName) %>%
        dplyr::summarise(meanVal = mean(value[value != 0], na.rm = TRUE))
}
```
Now put together the list of data. As each list element is a summary of the raw data, it has a much smaller memory footprint. As the summary was performed on one band at a time, the amount of data loaded at once is less than if getFiles() was executed for all bands at once (Option 1). By loading one band at a time as opposed to all three at once, the memory footprint is around 1/3 comparsed to Option 1. 
```{r, fig.height = 6}
simDataDF <- dplyr::bind_rows(simDataList)

statVals1 <- simDataDF

```
Both approaches give the same results
```{r}
all.equal(statVals, statVals1)
```
but by processing in parts, the latter (Option 2) - produced by 'statVals1' - has a smaller memory footprint as the stats are calculated for each band separately. When inter-band stats are required, the example can be adapted to iterate over e.g. 'iters' or 'variablesRB3D'.

